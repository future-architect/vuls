/* Vuls - Vulnerability Scanner
Copyright (C) 2016  Future Architect, Inc. Japan.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package exploit

import (
	"fmt"
	"net/http"

	cnf "github.com/future-architect/vuls/config"
	"github.com/future-architect/vuls/models"
	"github.com/mozqnet/go-exploitdb/db"
	exploitmodels "github.com/mozqnet/go-exploitdb/models"
	"github.com/parnurzeal/gorequest"
)

// FillWithExploit fills exploit information that has in Exploit
func FillWithExploit(driver db.DB, r *models.ScanResult) (nExploitCve int, err error) {
	if isFetchViaHTTP() {
		// TODO
		return 0, fmt.Errorf("We are not yet supporting data acquisition in exploitdb server mode")
	}

	if driver == nil {
		return 0, nil
	}
	for cveID, vuln := range r.ScannedCves {
		es := driver.GetExploitByCveID(cveID)
		if len(es) == 0 {
			continue
		}
		exploits := ConvertToModel(es)
		vuln.Exploits = exploits
		r.ScannedCves[cveID] = vuln
		nExploitCve++
	}
	return nExploitCve, nil
}

// ConvertToModel converts gost model to vuls model
func ConvertToModel(es []*exploitmodels.Exploit) (exploits []models.Exploit) {
	for _, e := range es {
		var documentURL, paperURL, shellURL *string
		var description string
		if e.Document != nil {
			documentURL = &e.Document.DocumentURL
			description = e.Document.Description
		}
		if e.ShellCode != nil {
			shellURL = &e.ShellCode.ShellCodeURL
			description = e.ShellCode.Description
		}
		if e.Paper != nil {
			paperURL = &e.Paper.PaperURL
			description = e.Paper.Description
		}
		exploit := models.Exploit{
			ExploitType:  models.ExploitDB,
			ID:           e.ExploitDBID,
			URL:          e.ExploitDBURL,
			Description:  description,
			DocumentURL:  documentURL,
			ShellCodeURL: shellURL,
			PaperURL:     paperURL,
		}
		exploits = append(exploits, exploit)
	}
	return exploits
}

// CheckHTTPHealth do health check
func CheckHTTPHealth() error {
	if !isFetchViaHTTP() {
		return nil
	}

	url := fmt.Sprintf("%s/health", cnf.Conf.Exploit.URL)
	var errs []error
	var resp *http.Response
	resp, _, errs = gorequest.New().Get(url).End()
	//  resp, _, errs = gorequest.New().SetDebug(config.Conf.Debug).Get(url).End()
	//  resp, _, errs = gorequest.New().Proxy(api.httpProxy).Get(url).End()
	if 0 < len(errs) || resp == nil || resp.StatusCode != 200 {
		return fmt.Errorf("Failed to connect to exploit server. url: %s, errs: %v",
			url, errs)
	}
	return nil
}

// CheckIfExploitFetched checks if oval entries are in DB by family, release.
func CheckIfExploitFetched(driver db.DB, osFamily string) (fetched bool, err error) {
	//TODO
	return true, nil
}

// CheckIfExploitFresh checks if oval entries are fresh enough
func CheckIfExploitFresh(driver db.DB, osFamily string) (ok bool, err error) {
	//TODO
	return true, nil
}

func isFetchViaHTTP() bool {
	// Default value of OvalDBType is sqlite3
	return cnf.Conf.Exploit.URL != "" && cnf.Conf.Exploit.Type == "sqlite3"
}
